<!DOCTYPE html>
<html>

<head>
	<style>
		body {
			background-color: black;
		}

		#contener {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: row;
			justify-content: center;
			align-items: center;
		}

		#game {
			position: relative;
			/*https://css-tricks.com/snippets/css/a-guide-to-flexbox/*/
			flex: 0 1 auto;
			border: 1px solid black;
			width: 50%;
			box-shadow: 0px 0px 200px #ffed00;
		}

		#game canvas {
			image-rendering: optimizeSpeed;
			image-rendering: -moz-crisp-edges;
			image-rendering: -webkit-optimize-contrast;
			image-rendering: optimize-contrast;
			image-rendering: crisp-edges;
			position: absolute;
			left: 0;
			top: 0;
			display: block;
		}
	</style>
	<script type="text/javascript" src="js/classes/Character.js"></script>
	<script type="text/javascript" src="js/classes/Player.js"></script>
	<script type="text/javascript" src="js/classes/Layer.js"></script>
	<script type="text/javascript" src="js/classes/Map.js"></script>
	<script type="text/javascript" src="js/classes/Generic.js"></script>
	<script type="text/javascript" src="js/classes/Menu.js"></script>
	<script src="/socket.io/socket.io.js"></script>
</head>

<body>
	<div id="contener">
		<div id="game"></div>
	</div>
	<script type="text/javascript">
		var tile_size = 32;

		layer_ui = new Layer("game", 'ui', 896, 928, 6);
		layer_players = new Layer("game", 'players', 896, 896, 4);
		layer_map = new Layer("game", 'map', 896, 896, 1);
		layer_items = new Layer("game", 'items', 896, 896, 3);
		layer_fx = new Layer("game", 'fx', 896, 896, 5);
		//	var vorace = layer_players.AddObjet(new Sprite("vorace", 0, 0, "players"));
		//console.log(vorace);
		//	vorace.current_anim = "nice_down";
		//TODO auto initialiser sur l'annimation wait !!! differente de down

		//TODO fractionner le script en 2 : graphique et communication avec le serveur
		function User(id, name, x, y, role, sprite) {
			this.id = id;
			this.name = name;
			this.role = role;
			this.x = x;
			this.y = y;
			this.dep = 0;
			this.eats = false;
			this.view = 3;
			this.sprite = sprite;
		}

		function get_vorace() {
			if (my.role == "V")
				return my;
			for (var i = 0; i < enemy.length; i++) {
				ei = enemy[i];
				if (ei.role == "V")
					return ei;
			}
			return (null);
		}

		var images = {};

		function create_img(tab) {
			for (var i = 0; i < tab.length; i++) {
				var img = new Image();
				var name = tab[i][0];
				img.src = tab[i][1];
				console.log('create :' + img.src);
				img.onload = function() {
					console.log('load : ' + this.src);
				};
				images[name] = img;
			}
		}
		//TODO Autoload tout ca, possible sans ajax ??????
		create_img([
			["wait", "/img/Vorace/wait.png"],
			["pbad", "/img/Vorace/bad.png"],
			["pdead", "/img/Vorace/dead.png"],
			["fbad", "/img/Phantom/bad.png"],
			["dead", "/img/Phantom/dead.png"],
			["nice", "/img/Phantom/nice.png"],
			["wall", "/img/Tiles/wall.png"],
			["wall_limit", "/img/Tiles/wall_limit.png"],
			["darkness", "/img/Tiles/darkness.png"],
			["ember", "/img/Items/ember.png"],
			["fspawn", "/img/Tiles/fspawn1.png"],
			["seringe", "/img/Items/seringe.png"],
			["floor", "/img/Tiles/floor.png"],
			["light", "/img/Fx/light.png"],
			["light2", "/img/Fx/light2.png"],
			["fantom_dead", "/img/fantom/fantom_dead.png"],
			["fantom_nice_left", "/img/fantom/nice_left.png"],
			["fantom_nice_right", "/img/fantom/nice_right.png"],
			["fantom_nice_down", "/img/fantom/nice_down.png"],
			["fantom_nice_up", "/img/fantom/nice_up.png"],
			["fantom_bad_down", "/img/fantom/bad_down.png"],
			["fantom_bad_up", "/img/fantom/bad_up.png"],
			["fantom_bad_left", "/img/fantom/bad_left.png"],
			["fantom_bad_right", "/img/fantom/bad_right.png"],
			["vorace_nice_left", "/img/vorace/nice_left.png"],
			["vorace_bad_right", "/img/vorace/bad_right.png"],
			["vorace_nice_right", "/img/vorace/nice_right.png"],
			["vorace_bad_down", "/img/vorace/bad_down.png"],
			["vorace_nice_down", "/img/vorace/nice_down.png"],
			["vorace_nice_up", "/img/vorace/nice_up.png"],
			["vorace_bad_up", "/img/vorace/bad_up.png"],
			["vorace_bad_left", "/img/vorace/bad_left.png"],
		]);

		// var c = document.getElementById("game");
		//c.getContext("2d");
		var my = null;
		var ingame = false;
		var enemy = [];
		var pseudo = prompt('Pseudo ?') || "User" + Math.floor((Math.random() * 4200) + 1000);
		var tab = [];
		var timer = 0;


		function get_user_by_id(id) {
			if (my.id == id)
				return my;
			for (var i = 0; i < enemy.length; i++) {
				ei = enemy[i];
				if (ei.id == id)
					return ei;
			}
			return (null);
		}

		tab = [];
		var socket = io.connect();
		socket.emit('pseudo', pseudo);
		socket.emit('play', true);
		socket.on('list_player', function(list) {
			clear_game();
			layer_ui.ctx.shadowColor = "yellow";
			layer_ui.ctx.shadowBlur = 10;
			layer_ui.ctx.fillStyle = "black";
			layer_ui.ctx.textAlign = "center";
			layer_ui.ctx.font = "50px Arial";
			layer_ui.ctx.fillText("Waiting " + (list['required'] - list['players'].length) + " players...", 448, 224);
			layer_ui.ctx.shadowBlur = 0;
		});


		socket.on('timer', function(t) {
			timer = t;
		});

		socket.on('move', function(list) {
			var v = get_vorace();
			if (v == null)
				return;
			v.x = -1;
			v.y = -1;
			for (var i = 0; i < list.length; i++) {
				l = list[i];
				e = get_user_by_id(l['id'])
				e.x = l['x'];
				e.y = l['y'];
				e.dep = l['dep'];
				e.eats = l['eat'];
				if (e.role == "F") {
					e.view = l['view-length'];
				}
				if (my.role == "V") {
					if (e == my && (tab[e.y][e.x] == 1 || tab[e.y][e.x] == 3))
						tab[e.y][e.x] = 9;
				} else {
					for (var j = 0; j < l['view'].length; j++) {
						var c = l['view'][j];
						tab[c["y"]][c["x"]] = c['val'];
						if (c['vorace'] == true) {
							v.x = c["x"];
							v.y = c["y"];
							v.dep = c["dep"];
						}
					}
				}
			}
			refresh_game();
		});

		socket.on('start', function(list) {
			for (i = 0; i < list['players'].length; i++) {
				if (list['players'][i].id == socket.id) {
					my = new User(list['players'][i].id, list['players'][i].pseudo, list['players'][i].x, list['players'][i].y, list['players'][i].role);
					if (my.role == "V") {
						my.sprite = new Sprite("vorace");
						my.sprite.current_anim = "nice_down";
					} else
						my.sprite = new Sprite("fantom")

					layer_players.AddObjet(my.sprite);
				} else {
					enemy.unshift(new User(list['players'][i].id, list['players'][i].pseudo, list['players'][i].x, list['players'][i].y, list['players'][i].role));
					if (enemy[0].role == "V") {
						enemy[0].sprite = new Sprite("vorace")
						enemy[0].sprite.current_anim = "nice_down";
					} else
						enemy[0].sprite = new Sprite("fantom")
					layer_players.AddObjet(enemy[0].sprite);
				}
			}
			map = new Map();
			tab = list['map']['map'];
			map.field = list['map']['map'];

			launch_game();
		});

		socket.on('end_game', function(msg) {
				my = null;
				ingame = false;
				enemy = [];
				move = 0;
				timer = 0;
				//UI
				layer_ui.ctx.shadowColor = "yellow";
				layer_ui.ctx.shadowBlur = 10;
				layer_ui.ctx.font = "50px Arial";
				layer_ui.ctx.fillStyle = "black";
				layer_ui.ctx.fillText(msg, 448, 224);
				layer_ui.ctx.font = "30px Arial";
				layer_ui.ctx.fillText("Press Enter for replay !", 448, 672);
				layer_ui.ctx.shadowBlur = 10;
			})
			//TODO trouver des images
		socket.on('life', function(life) {
			layer_ui.ctx.clearRect(0, 896, layer_ui.w, layer_ui.h);
			if (life == 0) {
				putimage(layer_ui.ctx, "pdead", 448 - 128, 448 - 128, 256, 256);
				return;
			}
			//UI
			layer_ui.ctx.font = "30px Arial";
			layer_ui.ctx.shadowColor = "yellow";
			layer_ui.ctx.shadowBlur = 10;
			layer_ui.ctx.fillStyle = "black";
			layer_ui.ctx.fillText((life - 1), 448, 924);
			layer_ui.ctx.shadowBlur = 0;
			putimage(layer_ui.ctx, "wait", 460, 900, 32, 32);
		})

		function light(x, y, nx, ny) {
			var rand = Math.floor(Math.random() * 10)
			layer_fx.ctx.save();
			layer_fx.ctx.fillStyle = "black"
			layer_fx.ctx.strokeRect(0, 0, layer_fx.canvas.width, layer_fx.canvas.height);
			layer_fx.ctx.globalCompositeOperation = "destination-out";
			putimage(layer_fx.ctx, "light2", x - nx / 2, y - ny / 2, nx - rand, ny - rand);
			layer_fx.ctx.restore();
		}
		// function putimage(ctx, path, x, y, nx, ny) {
		// 	//	var image = new Image();
		// 	//	image.src = path;
		// 	var image = get_img(path);
		// 	if (path == "pbad") {
		// 		nx = 60;
		// 		x = x - 30;
		// 	}
		// 	ctx.drawImage(image, x, y, nx, ny);
		// }

		function clear_game() {
			layer_players.ctx.clearRect(0, 0, layer_players.canvas.width, layer_players.canvas.height);
			layer_ui.ctx.clearRect(0, 0, layer_ui.canvas.width, layer_ui.canvas.height);
			layer_players.ctx.clearRect(0, 0, layer_players.canvas.width, layer_players.canvas.height);
		}

		function refresh_game() {
			// Create gradient
			//TODO 80ct val
			//TODO tout refaire le mode de rendu
			//TODO Gerer la direction et afficher les personnages en consequence
			//TODO Animation
			//TODO bordure sur les murs
			//IDEA Effet sonore
			//TODO Chat + log de qui a gagne quoi
			//IDEA differencier les fantomes
			//TODO (v1) Meilleur affichage en cas de victoire
			//IDEA tableau de score et systeme de round
			var tab = map.field;
			//my.sprite.Move(my.x, my.y, 125)
			my.sprite.posy = my.y;
			my.sprite.posx = my.x;
			set_anim_dep(my.dep.toString(), my.sprite);
			//		layer_players.ctx.clearRect(0, 0, layer_players.canvas.width, layer_players.canvas.height);
			layer_items.Clear();
			layer_ui.Clear();
			layer_fx.Clear();
			for (i = 0; i < enemy.length; i++) {
				e = enemy[i];
				e.sprite.posx = e.x;
				e.sprite.posy = e.y;
				set_anim_dep(e.dep.toString(), e.sprite);
			}
			//		lumiere pour les fantomes;
			if (my.role == 'F') {
				layer_fx.ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
				layer_fx.ctx.fillRect(0, 0, layer_fx.canvas.width, layer_fx.canvas.height);
				light(my.x * tile_size + tile_size / 2, my.y * tile_size + tile_size / 2, 150 + my.view * tile_size, 150 + my.view * tile_size);
				for (i = 0; i < enemy.length; i++) {
					e = enemy[i];
					if (e.role == 'V')
						continue;
					light(e.x * tile_size + tile_size / 2, e.y * tile_size + tile_size / 2, 150 + my.view * tile_size, 150 + my.view * tile_size);
				}
			}
			for (y = 0; y < tab.length; y++) {
				for (x = 0; x < tab[y].length; x++) {
					var img = "";

					var get = false;
					if (my.role == 'F') {

						for (i = 0; i < enemy.length; i++) {
							e = enemy[i];
							if (e.role == 'V') continue;
							if (Math.abs(e.x - x) + Math.abs(e.y - y) <= e.view) {
								get = true;
							}
						}
						if (Math.abs(my.x - x) + Math.abs(my.y - y) <= my.view) {
							get = true;
						}
					} else
						get = true;
					if (get == false) {

						//CHANGED effet rigolo quand le fantome bouge mais consome peut etre
						//putimage(layer_fx.ctx, "darkness", x * tile_size, y * tile_size, tile_size, tile_size);
						continue;
					}
					if (tab[y][x] == 3)
						img = "seringe";
					else if (tab[y][x] == 1)
						img = "ember";
					else
						img = "";
					if (img != "") {
						var rand = Math.floor(Math.random() * 5)
						putimage(layer_items.ctx, img, x * tile_size, y * tile_size, tile_size - rand, tile_size - rand);
					}
					// layer_fx.ctx.save();
					// layer_fx.ctx.shadowColor = 'yellow';
					// layer_fx.ctx.shadowBlur = 30;
					// layer_fx.ctx.globalCompositeOperation ="destination-in";
					// putimage(layer_fx.ctx, img, x * tile_size, y * tile_size, tile_size, tile_size);
					// layer_fx.ctx.restore();
					//	}
					//TODO il y a un glitch quand on se deplace parceque les interval de rafraichissement des animation et cette fonction qui se declenhe sous l'appel du seveur = fonction a detruire a 90%
				}
			}
		}
		var refresh_rate = 100;

		function launch_game() {
			timer = 0;
			ingame = true;
			map.Draw(layer_map.ctx);

			for (i = 0; i < enemy.length; i++) {
				e = enemy[i];
				e.sprite.Anim_start();
			}

			my.sprite.Anim_start();
			refresh_game();
			setInterval(function() {
				layer_players.Clear();
				layer_players.Draw();
			}, 25);
		}

		function set_anim_dep(dep, sprite) {

			var dep_tab = {
				0: "down",
				1: "left",
				2: "up",
				3: "right",
				4: "down"
			};
		//	console.log(dep);
			if (sprite.name == "vorace")
				if (timer == 0)
					sprite.current_anim = "nice_" + dep_tab[dep];
				else
					sprite.current_anim = "bad_" + dep_tab[dep];
			else if (sprite.name = "fantom")
				if (timer == 0)
					sprite.current_anim = "bad_" + dep_tab[dep];
				else
					sprite.current_anim = "nice_" + dep_tab[dep];
		}
		document.addEventListener('keydown', function(event) {
			if (!ingame) {
				if (event.keyCode == 13) //ENTER
					socket.emit('play', true);
				return;
			}
			//TODO fonction qui va set animation corretement (sprite.anicurent_anim = "animation")!!! attention si le mec tourne contre le mur.
			if (event.keyCode == 37 || event.keyCode == 65) //LEFT
				my.dep = 1;
			else if (event.keyCode == 38 || event.keyCode == 87) //UP
				my.dep = 2;
			else if (event.keyCode == 39 || event.keyCode == 68) //RIGHT
				my.dep = 3;
			else if (event.keyCode == 40 || event.keyCode == 83) //DOWN
				my.dep = 4;
			socket.emit('move', my.dep);
		});
	</script>
</body>

</html>